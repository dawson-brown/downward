#include "biased_minh.h"

using namespace std;

namespace intra_partition_biased {

IntraBiasedPolicy::IntraBiasedPolicy(const plugins::Options &opts)
    : NodePolicy(opts),
    tau(opts.get<double>("tau")),
    ignore_size(opts.get<bool>("ignore_size")),
    ignore_weights(opts.get<bool>("ignore_weights")),
    relative_h(opts.get<bool>("relative_h")),
    relative_h_offset(opts.get<int>("relative_h_offset")),
    current_sum(0.0),
    rng(utils::parse_rng_from_options(opts)) {}

NodeKey IntraBiasedPolicy::remove_next_state_from_partition(utils::HashMap<NodeKey, PartitionedState> &active_states, std::vector<NodeKey> &partition) { 
    int key = buckets.begin()->first;

    if (buckets.size() > 1) {
        double r = rng->random();
        if (relative_h) {
            double total_sum = 0;
            int i = relative_h_offset;
            for (auto it : buckets) {
                double s = std::exp(-1.0 * static_cast<double>(i) / tau);
                if (!ignore_size) s *= static_cast<double>(it.second.size());
                total_sum += s;
                ++i;
            }
            double p_sum = 0.0;
            i = relative_h_offset;
            for (auto it : buckets) {
                double p = std::exp(-1.0 * static_cast<double>(i) / tau) / total_sum;
                if (!ignore_size) p *= static_cast<double>(it.second.size());
                p_sum += p;
                ++i;
                if (r <= p_sum) {
                    key = it.first;
                    break;
                }
            }
        } else {
            double total_sum = current_sum;
            double p_sum = 0.0;
            for (auto it : buckets) {
                double p = 1.0 / total_sum;
                if (!ignore_weights) p *= std::exp(-1.0 * static_cast<double>(it.first) / tau);
                if (!ignore_size) p *= static_cast<double>(it.second.size());
                p_sum += p;
                if (r <= p_sum) {
                    key = it.first;
                    break;
                }
            }
        }
    }

    deque<NodeKey> &bucket = buckets[key];
    assert(!bucket.empty());
    NodeKey to_return = bucket.front();
    int partition_index = partition_indices.at(to_return);
    partition_indices.at(partition.back()) = partition_index;
    utils::swap_and_pop_from_vector(partition, partition_index);
    bucket.pop_front();

    if (bucket.empty()) {
        buckets.erase(key);
        if (ignore_size) {
            if (ignore_weights)
                current_sum -= 1;
            else if (!relative_h)
                current_sum -= std::exp(-1.0 * static_cast<double>(key) / tau);
        }
    }
    if (!ignore_size) {
        if (ignore_weights)
            current_sum -= 1;
        else if (!relative_h)
            current_sum -= std::exp(-1.0 * static_cast<double>(key) / tau);
    }
    return to_return;
}

void IntraBiasedPolicy::insert(EvaluationContext &context, NodeKey inserted, utils::HashMap<NodeKey, PartitionedState> active_states, std::vector<NodeKey> &partition) {
    int inserted_h = active_states.at(inserted).h;
    partition.push_back(inserted);
    buckets[inserted_h].push_back(inserted);
    partition_indices.at(inserted) = partition.size()-1;

    if (ignore_size) {
        if (buckets.find(inserted_h) == buckets.end()) {
            if (ignore_weights)
                current_sum += 1;
            else if (!relative_h)
                current_sum += std::exp(-1.0 * static_cast<double>(inserted_h) / tau);
        }
    } else {
        if (ignore_weights)
            current_sum += 1;
        else if (!relative_h)
            current_sum += std::exp(-1.0 * static_cast<double>(inserted_h) / tau);

    }
}

class IntraBiasedPolicyFeature : public plugins::TypedFeature<NodePolicy, IntraBiasedPolicy> {
public:
    IntraBiasedPolicyFeature() : TypedFeature("intra_biased") {
        document_subcategory("node_policies");
        document_title("Biased Random node selection");
        document_synopsis(
            "Biased sampling of nodes, favouring low h nodes.");
        add_option<bool>(
            "pref_only",
            "insert only nodes generated by preferred operators", "false");
        add_option<double>(
            "tau",
            "temperature parameter of softmin", "1.0");
        add_option<bool>(
            "ignore_size",
            "ignore bucket sizes", "false");
        add_option<bool>(
            "ignore_weights",
            "ignore weights of buckets", "false");
        add_option<bool>(
            "relative_h",
            "use relative positions of h-values", "false");
        add_option<int>(
            "relative_h_offset",
            "starting value of relative h-values", "0");
        utils::add_rng_options(*this);
        add_partition_options_to_feature(*this);
    }
};

static plugins::FeaturePlugin<IntraBiasedPolicyFeature> _plugin;
}