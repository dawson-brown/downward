#include "biased_minh.h"

using namespace std;

namespace intra_partition_biased {

IntraBiasedPolicy::IntraBiasedPolicy(const plugins::Options &opts)
    : NodePolicy(opts),
    evaluator(opts.get<shared_ptr<Evaluator>>("eval")),
    rng(utils::parse_rng_from_options(opts)),
    tau(opts.get<double>("tau")),
    ignore_size(opts.get<bool>("ignore_size")),
    ignore_weights(opts.get<bool>("ignore_weights")),
    relative_h(opts.get<bool>("relative_h")),
    relative_h_offset(opts.get<int>("relative_h_offset")) {}

int IntraBiasedPolicy::get_next_node(int partition_key) { 
    auto &partition = part_id_to_part.at(partition_key);

    auto &buckets = partition.h_buckets;
    int h = buckets.begin()->first;

    if (buckets.size() > 1) {
        double r = rng->random();
        if (relative_h) {
            double total_sum = 0;
            int i = relative_h_offset;
            for (auto it : buckets) {
                double s = std::exp(-1.0 * static_cast<double>(i) / tau);
                if (!ignore_size) s *= static_cast<double>(it.second.size());
                total_sum += s;
                ++i;
            }
            double p_sum = 0.0;
            i = relative_h_offset;
            for (auto it : buckets) {
                double p = std::exp(-1.0 * static_cast<double>(i) / tau) / total_sum;
                if (!ignore_size) p *= static_cast<double>(it.second.size());
                p_sum += p;
                ++i;
                if (r <= p_sum) {
                    h = it.first;
                    break;
                }
            }
        } else {
            double total_sum = partition.current_sum;
            double p_sum = 0.0;
            for (auto it : buckets) {
                double p = 1.0 / total_sum;
                if (!ignore_weights) p *= std::exp(-1.0 * static_cast<double>(it.first) / tau);
                if (!ignore_size) p *= static_cast<double>(it.second.size());
                p_sum += p;
                if (r <= p_sum) {
                    h = it.first;
                    break;
                }
            }
        }

    }

    vector<int> &bucket = buckets[h];
    assert(!bucket.empty());

    int result = utils::swap_and_pop_from_vector(bucket, rng->random(bucket.size()));
    if (bucket.empty()) {
        buckets.erase(h);
        if (ignore_size) {
            if (ignore_weights)
                partition.current_sum -= 1;
            else if (!relative_h)
                partition.current_sum -= std::exp(-1.0 * static_cast<double>(h) / tau);
        }
    }
    if (!ignore_size) {
        if (ignore_weights)
            partition.current_sum -= 1;
        else if (!relative_h)
            partition.current_sum -= std::exp(-1.0 * static_cast<double>(h) / tau);
    }
    return result;
}

void IntraBiasedPolicy::notify_insert(
        int partition_key,
        int node_key,
        bool new_partition,
        EvaluationContext &eval_context) 
{
    if (new_partition) {
        part_id_to_part.emplace(partition_key, BiasedPartition(0, map<int, vector<int>>()));
    }

    int eval = eval_context.get_evaluator_value_or_infinity(evaluator.get());
    auto &partition = part_id_to_part.at(partition_key);

    auto &buckets = partition.h_buckets;
    if (ignore_size) {
        if (buckets.find(eval) == buckets.end()) {
            if (ignore_weights)
                partition.current_sum += 1;
            else if (!relative_h)
                partition.current_sum += std::exp(-1.0 * static_cast<double>(eval) / tau);
        }
    } else {
        if (ignore_weights)
            partition.current_sum += 1;
        else if (!relative_h)
            partition.current_sum += std::exp(-1.0 * static_cast<double>(eval) / tau);

    }

    buckets[eval].push_back(node_key);

}


class IntraBiasedPolicyFeature : public plugins::TypedFeature<NodePolicy, IntraBiasedPolicy> {
public:
    IntraBiasedPolicyFeature() : TypedFeature("intra_biased") {
        document_subcategory("node_policies");
        document_title("Biased Random node selection");
        document_synopsis(
            "Biased sampling of nodes, favouring low h nodes.");
        add_option<shared_ptr<Evaluator>>("eval", "evaluator");
        add_option<bool>(
            "pref_only",
            "insert only nodes generated by preferred operators", "false");
        add_option<double>(
            "tau",
            "temperature parameter of softmin", "1.0");
        add_option<bool>(
            "ignore_size",
            "ignore bucket sizes", "false");
        add_option<bool>(
            "ignore_weights",
            "ignore weights of buckets", "false");
        add_option<bool>(
            "relative_h",
            "use relative positions of h-values", "false");
        add_option<int>(
            "relative_h_offset",
            "starting value of relative h-values", "0");
        utils::add_rng_options(*this);
        add_node_policy_options_to_feature(*this);
    }
};

static plugins::FeaturePlugin<IntraBiasedPolicyFeature> _plugin;
}