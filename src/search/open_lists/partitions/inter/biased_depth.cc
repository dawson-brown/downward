#include "biased_depth.h"

using namespace std;

namespace inter_biased_depth_partition {

InterBiasedDepthPolicy::InterBiasedDepthPolicy(const plugins::Options &opts)
    : PartitionPolicy(opts),
    rng(utils::parse_rng_from_options(opts)),
    tau(opts.get<double>("tau")),
    ignore_size(opts.get<bool>("ignore_size")),
    ignore_weights(opts.get<bool>("ignore_weights")),
    relative_h(opts.get<bool>("relative_h")),
    relative_h_offset(opts.get<int>("relative_h_offset")),
    current_sum(0.0) {}

int InterBiasedDepthPolicy::get_next_partition() { 
    //try to remove last partition
    if (last_chosen_depth != -1) {
        auto &last_bucket = buckets.at(last_chosen_depth);
        if (last_bucket[last_chosen_partition_i].second == 0) {
            utils::swap_and_pop_from_vector(last_bucket, last_chosen_partition_i);
            if (last_bucket.empty()) {
                buckets.erase(last_chosen_depth);
                if (ignore_size) {
                    if (ignore_weights)
                        current_sum -= 1;
                    else if (!relative_h)
                        current_sum -= std::exp(static_cast<double>(last_chosen_depth) / tau); //remove -1.0 *
                }
            }
            if (!ignore_size) {
                if (ignore_weights)
                    current_sum -= 1;
                else if (!relative_h)
                    current_sum -= std::exp(static_cast<double>(last_chosen_depth) / tau); //remove -1.0 *
            }
        }
    }
    
    int count_i = 0;
    int key = buckets.begin()->first;
    if (buckets.size() > 1) {
        double r = rng->random();
        if (relative_h) {
            double total_sum = 0;
            int i = relative_h_offset;
            for (auto it : buckets) {
                double s = std::exp(static_cast<double>(i) / tau); //remove -1.0 *  
                if (!ignore_size) s *= static_cast<double>(it.second.size());
                total_sum += s;
                ++i;
            }
            double p_sum = 0.0;
            i = relative_h_offset;
            for (auto it : buckets) {
                double p = std::exp(static_cast<double>(i) / tau) / total_sum; //remove -1.0 * 
                if (!ignore_size) p *= static_cast<double>(it.second.size());
                p_sum += p;
                ++i;
                if (r <= p_sum) {
                    key = it.first;
                    break;
                }
            }
        } else {
            double total_sum = current_sum;
            double p_sum = 0.0;
            for (auto it : buckets) {
                double p = 1.0 / total_sum;
                if (!ignore_weights) p *= std::exp(static_cast<double>(it.first) / tau); //remove -1.0 *
                if (!ignore_size) p *= static_cast<double>(it.second.size());
                p_sum += p;
                if (r <= p_sum) {
                    key = it.first;
                    break;
                }
                count_i+=1; 
            }
        }
    }

    vector<pair<int, int>> &h_bucket = buckets[key];
    assert(!h_bucket.empty());
    last_chosen_partition_i = rng->random(h_bucket.size());
    last_chosen_depth = key;
    pair<int, int> &result = h_bucket[last_chosen_partition_i];
    result.second-=1;
    return result.first;    
}

void InterBiasedDepthPolicy::notify_insert(
        int partition_key,
        int node_key,
        bool new_partition,
        EvaluationContext &eval_context) 
{
    if (new_partition) {
        int key = last_chosen_depth + 1;
        if (ignore_size) {
            if (buckets.find(key) == buckets.end()) {
                if (ignore_weights)
                    current_sum += 1;
                else if (!relative_h)
                    current_sum += std::exp(static_cast<double>(key) / tau); //remove -1.0 *
            }
        } else {
            if (ignore_weights)
                current_sum += 1;
            else if (!relative_h)
                current_sum += std::exp(static_cast<double>(key) / tau); //remove -1.0 *
        }
        buckets[key].push_back(make_pair(partition_key, 1));
    } else {
        buckets.at(last_chosen_depth)[last_chosen_partition_i].second +=1;
    }
}

class InterBiasedDepthPolicyFeature : public plugins::TypedFeature<PartitionPolicy, InterBiasedDepthPolicy> {
public:
    InterBiasedDepthPolicyFeature() : TypedFeature("inter_biased_depth") {
        document_subcategory("partition_policies");
        document_title("Biased depth partition selection");
        document_synopsis(
            "Choose the next partition biased in favour of high depth partitions.");
        add_option<bool>(
            "pref_only",
            "insert only nodes generated by preferred operators", "false");
        add_option<double>(
            "tau",
            "temperature parameter of softmin", "1.0");
        add_option<bool>(
            "ignore_size",
            "ignore bucket sizes", "false");
        add_option<bool>(
            "ignore_weights",
            "ignore weights of buckets", "false");
        add_option<bool>(
            "relative_h",
            "use relative positions of h-values", "false");
        add_option<int>(
            "relative_h_offset",
            "starting value of relative h-values", "0");
        utils::add_rng_options(*this);
        add_partition_policy_options_to_feature(*this);
    }
};

static plugins::FeaturePlugin<InterBiasedDepthPolicyFeature> _plugin;
}