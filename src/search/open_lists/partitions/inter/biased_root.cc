#include "biased_root.h"

using namespace std;

namespace inter_biased_root_partition {

InterBiasedRootPolicy::InterBiasedRootPolicy(const plugins::Options &opts)
    : PartitionPolicy(opts),
    evaluator(opts.get<shared_ptr<Evaluator>>("eval")),
    rng(utils::parse_rng_from_options(opts)),
    tau(opts.get<double>("tau")),
    ignore_size(opts.get<bool>("ignore_size")),
    ignore_weights(opts.get<bool>("ignore_weights")),
    relative_h(opts.get<bool>("relative_h")),
    relative_h_offset(opts.get<int>("relative_h_offset")),
    current_sum(0.0) {}


int InterBiasedRootPolicy::get_next_partition() { 
    //try to remove last partition
    if (last_chosen_h != -1) {
        auto &last_bucket = buckets.at(last_chosen_h);
        if (last_bucket[last_chosen_partition_i].second == 0) {
            utils::swap_and_pop_from_vector(last_bucket, last_chosen_partition_i);
            if (last_bucket.empty()) {
                buckets.erase(last_chosen_h);
                if (ignore_size) {
                    if (ignore_weights)
                        current_sum -= 1;
                    else if (!relative_h)
                        current_sum -= std::exp(-1.0 * static_cast<double>(last_chosen_h) / tau);
                }
            }
            if (!ignore_size) {
                if (ignore_weights)
                    current_sum -= 1;
                else if (!relative_h)
                    current_sum -= std::exp(-1.0 * static_cast<double>(last_chosen_h) / tau);
            }
        }
    }
    
    // int count_i = 0; // REMOVE
    int key = buckets.begin()->first;
    if (buckets.size() > 1) {
        double r = rng->random();
        if (relative_h) {
            double total_sum = 0;
            int i = relative_h_offset;
            for (auto it : buckets) {
                double s = std::exp(-1.0 * static_cast<double>(i) / tau);
                if (!ignore_size) s *= static_cast<double>(it.second.size());
                total_sum += s;
                ++i;
            }
            double p_sum = 0.0;
            i = relative_h_offset;
            for (auto it : buckets) {
                double p = std::exp(-1.0 * static_cast<double>(i) / tau) / total_sum;
                if (!ignore_size) p *= static_cast<double>(it.second.size());
                p_sum += p;
                ++i;
                if (r <= p_sum) {
                    key = it.first;
                    break;
                }
            }
        } else {
            double total_sum = current_sum;
            double p_sum = 0.0;
            for (auto it : buckets) {
                double p = 1.0 / total_sum;
                if (!ignore_weights) p *= std::exp(-1.0 * static_cast<double>(it.first) / tau);
                if (!ignore_size) p *= static_cast<double>(it.second.size());
                p_sum += p;
                if (r <= p_sum) {
                    key = it.first;
                    break;
                }
                // count_i+=1; // REMOVE
            }
        }
    }

    // if (count_i < counts.size()) { // REMOVE
    //     counts[count_i]+=1;
    // }

    vector<pair<int, int>> &h_bucket = buckets[key];
    assert(!h_bucket.empty());
    last_chosen_partition_i = rng->random(h_bucket.size());
    last_chosen_h = key;
    pair<int, int> &result = h_bucket[last_chosen_partition_i];
    result.second-=1;
    return result.first;    
}

void InterBiasedRootPolicy::notify_insert(
        int partition_key,
        int node_key,
        bool new_partition,
        EvaluationContext &eval_context) 
{
    // if (node_key % 500 == 0) {
    //     cout << counts << endl;
    // }

    if (new_partition) {
        int key = eval_context.get_evaluator_value(evaluator.get());
        if (ignore_size) {
            if (buckets.find(key) == buckets.end()) {
                if (ignore_weights)
                    current_sum += 1;
                else if (!relative_h)
                    current_sum += std::exp(-1.0 * static_cast<double>(key) / tau);
            }
        } else {
            if (ignore_weights)
                current_sum += 1;
            else if (!relative_h)
                current_sum += std::exp(-1.0 * static_cast<double>(key) / tau);
        }
        buckets[key].push_back(make_pair(partition_key, 1));
    } else {
        buckets.at(last_chosen_h)[last_chosen_partition_i].second +=1;
    }
}

class InterBiasedRootPolicyFeature : public plugins::TypedFeature<PartitionPolicy, InterBiasedRootPolicy> {
public:
    InterBiasedRootPolicyFeature() : TypedFeature("inter_biased_root") {
        document_subcategory("partition_policies");
        document_title("Biased root partition selection");
        document_synopsis(
            "Choose the next partition biased in favour of low h partition roots.");
        add_option<shared_ptr<Evaluator>>("eval", "evaluator");
        add_option<bool>(
            "pref_only",
            "insert only nodes generated by preferred operators", "false");
        add_option<double>(
            "tau",
            "temperature parameter of softmin", "1.0");
        add_option<bool>(
            "ignore_size",
            "ignore bucket sizes", "false");
        add_option<bool>(
            "ignore_weights",
            "ignore weights of buckets", "false");
        add_option<bool>(
            "relative_h",
            "use relative positions of h-values", "false");
        add_option<int>(
            "relative_h_offset",
            "starting value of relative h-values", "0");
        utils::add_rng_options(*this);
        add_partition_policy_options_to_feature(*this);
    }
};

static plugins::FeaturePlugin<InterBiasedRootPolicyFeature> _plugin;
}